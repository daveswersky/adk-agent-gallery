# ADK Event View - Implementation Plan

## Goal

To provide developers with a real-time view of the events generated by the `google-adk` `Runner` during an agent's execution. This will offer deeper insight into the agent's lifecycle and decision-making process, aiding in debugging and development.

## High-Level Plan

1.  **Backend:**
    -   Integrate the `EventStreamingPlugin` into the `agent_host.py` to capture events from the ADK `Runner`.
    -   Establish a communication channel to forward these events from the `agent_host` subprocess to the main backend server.
    -   Broadcast the events to all connected frontend clients via the existing WebSocket connection.
2.  **Frontend:**
    -   Update the `useManagementSocket.ts` hook to handle the new `agent_event` message type from the WebSocket.
    -   Create a new "Events" tab within the `InfoPane.tsx` component.
    -   Develop a component to render the stream of structured event data in a clear, readable format within the new tab.
    -   Rename the existing "Events" tab to "Debug".

## Detailed Steps

### Phase 1: Backend Implementation

1.  **`backend/event_streaming_plugin.py`:**
    -   Review the existing `EventStreamingPlugin`. Ensure it captures all relevant event types by overriding the `on_*` methods from the `BasePlugin`.
    -   The plugin should serialize each event into a JSON format.

2.  **`backend/agent_host.py`:**
    -   Instantiate the `EventStreamingPlugin`.
    -   Modify the `Runner` initialization to include `plugins=[EventStreamingPlugin(...)]`.
    -   The plugin will need a callback function to send the serialized event data back to the main backend. This will likely involve writing to a dedicated pipe or using the existing standard output with a special prefix to distinguish events from logs.

3.  **`backend/main.py`:**
    -   In the `handle_subprocess_output` function, add logic to detect and parse the event data coming from the `agent_host` subprocess.
    -   Define a new WebSocket message format for events, e.g., `{ "type": "agent_event", "agent": "agent_name", "event_data": { ... } }`.
    -   When an event is received, broadcast it to all connected clients using the `connection_manager`.

### Phase 2: Frontend Implementation

1.  **`frontend/types.ts`:**
    -   Define a new `AgentEvent` type to match the structure of the event data sent by the backend.
    -   Add `AgentEvent` to the `ServerMessage` union type.

2.  **`frontend/hooks/useManagementSocket.ts`:**
    -   Add state to store the received agent events, likely a simple array: `const [agentEvents, setAgentEvents] = useState<AgentEvent[]>([]);`.
    -   In the `onmessage` handler for the WebSocket, add a new `else if (message.type === 'agent_event')` block.
    -   Inside this block, update the `agentEvents` state with the new event.

3.  **`frontend/components/InfoPane.tsx`:**
    -   Modify the tab structure. Rename the "Events" tab to "Debug".
    -   Add a new "Events" tab.
    -   Pass the `agentEvents` state and the `clearAgentEvents` function (to be created in `useManagementSocket.ts`) as props to the component rendered by the "Events" tab.

4.  **Create `frontend/components/EventViewer.tsx`:**
    -   This new component will receive the list of `agentEvents` as a prop.
    -   It will map over the events and render them. Each event could be displayed in a collapsible block, showing the event name, timestamp, and a formatted view of the event's JSON payload.
    -   Add a "Clear" button to allow users to clear the event log.

## Testing Strategy

-   **Backend:**
    -   Add unit tests for the `EventStreamingPlugin` to ensure it correctly captures and serializes events.
    -   Add an integration test to verify that events are correctly passed from the `agent_host` to the main backend and broadcasted over the WebSocket.
-   **Frontend:**
    -   Add a Storybook story for the `EventViewer` component to test its rendering with various event types.
    -   Update Playwright E2E tests to open the "Events" tab and verify that events appear when an agent is run.