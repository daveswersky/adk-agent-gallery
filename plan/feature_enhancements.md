# Feature Enhancements

This document is a running list of ideas for future enhancements to the Agent Gallery project.

## Epics

- [A2A support](./epic/A2A-Support.md)
  - **Effort Assessment: EPIC**
  - The first phase of this epic involves a backend re-architecture to enable the gallery to run self-contained, "self-hosted" agents (like the A2A samples) which are required for agent-to-agent communication.
  - **Architecture:** A "dual-runner" architecture will be implemented where the host remains responsible for the full lifecycle of all agents, including dependency management. A new `A2AAgentRunner` will be created to handle self-hosted agents, while the existing `AgentRunner` will manage the default "raw" ADK agents.
  - **Configuration:** A new `agent_configs` section in `gallery.config.yaml` will provide a centralized way to define an agent's `type` (e.g., `a2a`), its `dependencies` file (e.g., `pyproject.toml`), and its `entrypoint` script (e.g., `__main__.py`). This ensures a consistent and explicit configuration model.
  - Subsequent phases will build on this foundation to implement the actual message-passing infrastructure.
- [Container Mode](./epic/Container-Mode.md)
  - **Effort Assessment: EPIC**
  - This represents a major architectural addition, creating a parallel agent execution engine using Docker.
  - **Key challenges include:
    - **New `ContainerAgentRunner`:** A new runner class would be needed to manage the entire Docker lifecycle: finding/generating Dockerfiles, running `docker build`, `docker run`, and `docker stop`.
    - **Backend Refactoring:** The core backend logic would need significant changes to support both the existing `AgentRunner` and the new `ContainerAgentRunner`, allowing the user to switch between them.
    - **Event Streaming:** The current event streaming mechanism relies on an OS-level pipe, which will not work for containerized agents. A new, non-trivial solution (e.g., a dedicated WebSocket connection from the agent back to the backend) would need to be designed and implemented to stream structured events.
    - **New System Dependency:** This feature introduces a hard dependency on a running Docker daemon, which adds complexity to the setup and user experience.
- [Multi-session support](./epic/Multi-session-support.md)
  - **Effort Assessment: EPIC**
  - While the frontend has a surprisingly robust session management service already built, the backend is completely stateless, making this a backend-heavy epic.
  - **Key challenges include:**
    - **Backend Rearchitecture:** The interaction between the main backend and the agent subprocesses must be fundamentally changed. The current stateless `run_turn` endpoint needs to be replaced with a stateful model.
    - **ADK Integration:** The `agent_host.py` script must be rewritten to use the stateful `google.adk.runners.Runner` and `Session` objects, passing `session_id` and conversation history with each turn. This is the most critical and complex part of the work.
    - **API Changes:** The `/run_turn` endpoint in `main.py` and the `AgentRunner` class need to be updated to accept and pass `session_id` and history.
    - **Persistence:** To make sessions useful, a persistence layer (e.g., a simple file-based or DB store) would be needed to save, load, and delete session history.
    - **Frontend UI:** A UI for creating, selecting, saving, and deleting sessions for an agent would need to be built. The underlying frontend services for this are already largely in place.
- Evaluation support
  - **Effort Assessment: EPIC**
  - This feature is about building a web UI and backend system to manage the ADK's command-line evaluation tool (`adk evaluate`). While the core evaluation logic is provided by the ADK, the web integration is a large project.
  - **Key challenges include:**
    - **Backend Subprocess Management:** A new backend system is needed to manage the lifecycle of `adk evaluate` runs as one-off, long-running tasks.
    - **File Management:** The backend must handle the storage and management of evaluation dataset files (e.g., YAML/JSON) uploaded by the user.
    - **API and Data Handling:** A new set of API endpoints is required to manage datasets, trigger evaluation runs, and retrieve the resulting reports. The backend will also need to parse the report files generated by the ADK tool.
    - **New Frontend UI:** This requires a completely new, dedicated section in the UI for managing evaluation datasets and viewing the complex, structured data from evaluation reports.
- [Agent Deployment Support](./epic/Agent-Deployment-Support.md)
  - **Effort Assessment: EPIC**
  - This feature expands the gallery from a local development tool to a cloud deployment portal.
  - **Key challenges include:**
    - **Cloud Authentication:** The backend needs to be configured to use user-provided Google Cloud credentials (e.g., Application Default Credentials).
    - **Packaging & Containerization:** A new backend process is required to package agent source code into a container image, likely requiring a Docker daemon to be available. This involves finding or generating a Dockerfile and pushing the built image to a container registry.
    - **Asynchronous Deployment Engine:** The backend needs a new service to manage the long-running deployment process (e.g., calling `gcloud run deploy`). This must be asynchronous to avoid blocking the server.
    - **Real-time Feedback:** The deployment engine must stream logs from the packaging and deployment process back to the frontend over the WebSocket.
    - **New Frontend UI:** A substantial new UI is needed for configuring deployment parameters (Project ID, region, etc.), triggering the deployment, and viewing the live logs and final status.
    - Cloud Run
    - Agent Engine
- [Live agent support](./epic/Live-agent-support.md)
  - **Effort Assessment: EPIC**
  - This feature involves integrating real-time, streaming voice/video agents (Gemini Live Agents), which operate on a completely different paradigm than the current text-based, turn-based ADK agents.
  - **Integration Strategy:** This would be a parallel, side-by-side integration. It would not replace the existing agent runner but would add a new, distinct "mode" to the application.
  - **Key challenges include:**
    - **New Real-time Backend:** A new backend service is required to manage the persistent, low-latency, bi-directional stream with the Gemini Live API. This is entirely separate from the existing FastAPI request-response logic.
    - **New Frontend UI:** A completely new `LiveChatInterface.tsx` component is needed to handle microphone input, real-time audio playback, and potentially video streams. The existing text-based chat UI cannot be reused.
    - **Browser Media APIs:** The frontend will need to use low-level browser APIs (`getUserMedia`, etc.) to capture and process audio/video.
    - **New Communication Protocol:** The application's communication layer would need to be enhanced to support real-time streaming protocols (e.g., WebRTC or a specialized WebSocket setup) alongside the existing notification-based WebSocket.

## Features

- ~~[Grouped Agent List](./feature/grouped-agent-list.md)~~: Display agents in collapsible groups based on the `agent_roots` defined in `gallery.config.yaml`.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a frontend-only enhancement to improve the organization and presentation of agents in the sidebar.
  - **Backend:** No backend changes are required.
  - **Frontend:** Requires fetching and parsing `gallery.config.yaml` to get the agent groups. The `AgentSidebar.tsx` component will be updated to render agents in collapsible sections. State management in `useManagementSocket.ts` will be adjusted to handle the grouped data structure.
- ~~[Warn on Browser Refresh](./feature/Warn-on-Refresh.md)~~: Warn user on browser refresh that sessions will be reset.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a straightforward, frontend-only feature.
  - **Backend:** No backend changes are required as session state is managed on the client.
  - **Frontend:** Requires adding a `beforeunload` event listener in a top-level component. The listener will check if any active sessions exist and, if so, trigger the browser's native confirmation prompt.
- ~~[Markdown Support](./feature/Markdown-Support.md)~~: Display markdown-formatted responses from the model in the ChatInterface.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a well-defined feature primarily focused on the frontend.
  - **Backend:** No backend changes are required. Agent responses are passed through as-is.
  - **Frontend:** Requires integrating a Markdown rendering library (like `react-markdown`) into the `ChatInterface.tsx` component. The component that displays agent messages will need to be updated to parse and render the markdown content instead of displaying it as plain text. Minimal state management changes are needed.
- ~~[Agent Code View](./feature/Agent-Code-View.md)~~: click a code icon in an agent card to see the code in a popup or viewer pane
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a well-defined feature with a clear implementation path.
  - **Backend:** Requires a new API endpoint (e.g., `/agents/{agent_id}/code`) that reads and returns the content of the agent's primary Python file. The backend already has logic for locating agent files.
  - **Frontend:** Requires adding a new icon/button to the `AgentListItem` component, a new function to fetch the code from the backend, and a new modal component to display the code. No major state management or architectural changes are needed.
- ~~[Improved Code Viewer](./feature/Improved-Code-Viewer.md)~~: In the Code Viewer, show a tabbed view for agents that have sub-agents.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This feature enhances the existing Code Viewer.
  - **Backend:** Requires a new API endpoint to get the code for an agent and its sub-agents. This will involve identifying sub-agents (e.g., by looking for a `sub_agents` directory) and reading their code.
  - **Frontend:** The `CodeViewerModal.tsx` component will be updated to fetch the sub-agent code and display it in a tabbed interface.
- ~~[README display for non-running agents](./feature/README-display.md)~~: Display the README.md file for a selected agent in the ChatInterface pane when the agent is not running.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a quality-of-life feature that requires coordinated changes between the backend and frontend.
  - **Backend:** Requires a new API endpoint (e.g., `/agents/{agent_id}/readme`) that finds an agent's `README.md` file and returns its content.
  - **Frontend:** Requires several changes:
    - The `AgentSidebar.tsx` component must be modified to allow selecting agents that are not currently running.
    - State management in `App.tsx` must be updated to fetch and store the README content when a non-running agent is selected.
    - The `ChatInterface.tsx` component needs to be updated to display the fetched Markdown content when available, instead of the chat view.
- [ADK Event View](./feature/Event-Viewer.md): Display a stream of ADK events in the InfoPane.
  - **Effort Assessment: FEATURE**
  - This feature will use the `EventStreamingPlugin` to capture and forward all ADK events (e.g., `on_prompt_start`, `on_tool_code_generated`, `on_llm_chunk`) from the agent subprocess to the frontend.
  - **Backend:** The `EventStreamingPlugin` needs to be attached to the `Runner` in `agent_host.py`. The plugin will send each event to the main backend, which will then broadcast it over the WebSocket.
  - **Frontend:** The `InfoPane.tsx` component will be updated with a new "Events" tab to display the structured event data. The existing "Logs" tab will remain. The `useManagementSocket.ts` hook will be updated to handle the new event message type.
- [Artifact service support](./feature/Artifact-service-support.md)
  - **Effort Assessment: FEATURE**
  - This feature is about integrating the ADK's built-in Artifact Service, not building one from scratch. The work is primarily plumbing and integration.
  - **Key tasks include:**
    - **ADK Integration:** The `agent_host.py` script must be updated to instantiate an `ArtifactService` (e.g., `InMemoryArtifactService`) and pass it to the ADK `Runner`.
    - **Agent-level API:** The agent's internal web server (in `agent_host.py`) needs a new endpoint to retrieve artifacts by name from the `ArtifactService`.
    - **Backend Proxy:** The main backend (`main.py`) needs a new endpoint that proxies artifact download requests from the frontend to the correct agent subprocess.
    - **Frontend:** The chat UI needs to be updated to recognize `artifact://` URIs in agent responses and render them as clickable download links pointing to the new backend proxy endpoint.
- [Hot-Reload Configuration](./feature/Hot-Reload-Config.md): Automatically reload the agent list when `gallery.config.yaml` is modified.
  - **Effort Assessment: FEATURE**
  - This is a developer experience enhancement that removes the need to restart the backend server after changing the configuration.
  - **Backend:** Requires adding a file-watching library (like `watchfiles`) to monitor `gallery.config.yaml`. A background task will be started with the server to watch for changes. When a change is detected, the backend will re-parse the configuration, re-discover the agents, and broadcast a new `agents_update` message to all connected clients via the WebSocket.
  - **Frontend:** The `useManagementSocket.ts` hook will be updated to handle the new `agents_update` message. Upon receiving this message, it will update the `agents` state with the new list, preserving the status of any agents that are currently running.


## TASKS
- Subagent support/testing (tools work, need to try subagent transfers)
- Test all ADK Sample Agents
- Agent Gallery Cloud Run deployment
    - Feature: instance-per agent option


## AGENTS
- ADK Samples
- To be added
    - A2A Samples
    - Implementation of https://cloud.google.com/architecture/multiagent-ai-system 
    - Agentic Design Patterns: https://docs.google.com/document/d/1rsaK53T3Lg5KoGwvf8ukOUvbELRtH-V0LnOIFDxBryE/edit?tab=t.0#heading=h.pxcur8v2qagu


## BACKLOG
- ~~Add "clear" button to agent filter. Circled X in right side of filter field~~ (Done)
- ~~When starting an agent discovered by the filter, clear the filter on start~~ (Done)
- subprocess check when processes crash
- Warn on unexpanded variables in `agents.config.yaml`. If a value contains a `$` after expansion, it likely means a host environment variable is missing. (may fix)
- Model Context Protocol example

## ASSISTED DEV IDEAS
- CLI Extension: /handoff
  - Summarizes the current state of progress into a prompt that can be used to restart after a /clear command.
- CLI Extension: /startup
  - Reads Gemini.md for directives and reports them, ensuring that they are active in the current session.