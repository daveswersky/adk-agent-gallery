# Feature Enhancements

This document is a running list of ideas for future enhancements to the Agent Gallery project.

## Epics

- [A2A support](./epic/A2A-Support.md)
  - **Effort Assessment: EPIC**
  - Implementing Agent-to-Agent communication would require a significant architectural change. The current architecture isolates each agent in its own subprocess with no direct communication channels.
  - Key challenges include:
    - **Communication Infrastructure:** Requires designing and building a new system for inter-agent message passing, either through the central backend acting as a broker or by implementing a service discovery mechanism for direct agent-to-agent HTTP calls.
    - **Core Agent Logic (`google-adk`):** The `google-adk` `Runner` would need fundamental changes to handle and process incoming events/messages from other agents, not just from the user.
    - **API and State Management:** The backend's concept of a "turn" would need to evolve to manage multi-agent conversational state.
    - **Frontend UI:** The UI would require substantial work to visualize and manage A2A interactions (e.g., grouping agents that are communicating).
  - This epic would need to be broken down into smaller, more manageable features.
- [Container Mode](./epic/Container-Mode.md)
  - **Effort Assessment: EPIC**
  - This represents a major architectural addition, creating a parallel agent execution engine using Docker.
  - **Key challenges include:
    - **New `ContainerAgentRunner`:** A new runner class would be needed to manage the entire Docker lifecycle: finding/generating Dockerfiles, running `docker build`, `docker run`, and `docker stop`.
    - **Backend Refactoring:** The core backend logic would need significant changes to support both the existing `AgentRunner` and the new `ContainerAgentRunner`, allowing the user to switch between them.
    - **Event Streaming:** The current event streaming mechanism relies on an OS-level pipe, which will not work for containerized agents. A new, non-trivial solution (e.g., a dedicated WebSocket connection from the agent back to the backend) would need to be designed and implemented to stream structured events.
    - **New System Dependency:** This feature introduces a hard dependency on a running Docker daemon, which adds complexity to the setup and user experience.
- [Multi-session support](./epic/Multi-session-support.md)
  - **Effort Assessment: EPIC**
  - While the frontend has a surprisingly robust session management service already built, the backend is completely stateless, making this a backend-heavy epic.
  - **Key challenges include:**
    - **Backend Rearchitecture:** The interaction between the main backend and the agent subprocesses must be fundamentally changed. The current stateless `run_turn` endpoint needs to be replaced with a stateful model.
    - **ADK Integration:** The `agent_host.py` script must be rewritten to use the stateful `google.adk.runners.Runner` and `Session` objects, passing `session_id` and conversation history with each turn. This is the most critical and complex part of the work.
    - **API Changes:** The `/run_turn` endpoint in `main.py` and the `AgentRunner` class need to be updated to accept and pass `session_id` and history.
    - **Persistence:** To make sessions useful, a persistence layer (e.g., a simple file-based or DB store) would be needed to save, load, and delete session history.
    - **Frontend UI:** A UI for creating, selecting, saving, and deleting sessions for an agent would need to be built. The underlying frontend services for this are already largely in place.
- Evaluation support
  - **Effort Assessment: EPIC**
  - This feature is about building a web UI and backend system to manage the ADK's command-line evaluation tool (`adk evaluate`). While the core evaluation logic is provided by the ADK, the web integration is a large project.
  - **Key challenges include:**
    - **Backend Subprocess Management:** A new backend system is needed to manage the lifecycle of `adk evaluate` runs as one-off, long-running tasks.
    - **File Management:** The backend must handle the storage and management of evaluation dataset files (e.g., YAML/JSON) uploaded by the user.
    - **API and Data Handling:** A new set of API endpoints is required to manage datasets, trigger evaluation runs, and retrieve the resulting reports. The backend will also need to parse the report files generated by the ADK tool.
    - **New Frontend UI:** This requires a completely new, dedicated section in the UI for managing evaluation datasets and viewing the complex, structured data from evaluation reports.
- [Agent Deployment Support](./epic/Agent-Deployment-Support.md)
  - **Effort Assessment: EPIC**
  - This feature expands the gallery from a local development tool to a cloud deployment portal.
  - **Key challenges include:**
    - **Cloud Authentication:** The backend needs to be configured to use user-provided Google Cloud credentials (e.g., Application Default Credentials).
    - **Packaging & Containerization:** A new backend process is required to package agent source code into a container image, likely requiring a Docker daemon to be available. This involves finding or generating a Dockerfile and pushing the built image to a container registry.
    - **Asynchronous Deployment Engine:** The backend needs a new service to manage the long-running deployment process (e.g., calling `gcloud run deploy`). This must be asynchronous to avoid blocking the server.
    - **Real-time Feedback:** The deployment engine must stream logs from the packaging and deployment process back to the frontend over the WebSocket.
    - **New Frontend UI:** A substantial new UI is needed for configuring deployment parameters (Project ID, region, etc.), triggering the deployment, and viewing the live logs and final status.
    - Cloud Run
    - Agent Engine
- [Live agent support](./epic/Live-agent-support.md)
  - **Effort Assessment: EPIC**
  - This feature involves integrating real-time, streaming voice/video agents (Gemini Live Agents), which operate on a completely different paradigm than the current text-based, turn-based ADK agents.
  - **Integration Strategy:** This would be a parallel, side-by-side integration. It would not replace the existing agent runner but would add a new, distinct "mode" to the application.
  - **Key challenges include:**
    - **New Real-time Backend:** A new backend service is required to manage the persistent, low-latency, bi-directional stream with the Gemini Live API. This is entirely separate from the existing FastAPI request-response logic.
    - **New Frontend UI:** A completely new `LiveChatInterface.tsx` component is needed to handle microphone input, real-time audio playback, and potentially video streams. The existing text-based chat UI cannot be reused.
    - **Browser Media APIs:** The frontend will need to use low-level browser APIs (`getUserMedia`, etc.) to capture and process audio/video.
    - **New Communication Protocol:** The application's communication layer would need to be enhanced to support real-time streaming protocols (e.g., WebRTC or a specialized WebSocket setup) alongside the existing notification-based WebSocket.

## Features

- ~~[Grouped Agent List](./feature/grouped-agent-list.md)~~: Display agents in collapsible groups based on the `agent_roots` defined in `gallery.config.yaml`.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a frontend-only enhancement to improve the organization and presentation of agents in the sidebar.
  - **Backend:** No backend changes are required.
  - **Frontend:** Requires fetching and parsing `gallery.config.yaml` to get the agent groups. The `AgentSidebar.tsx` component will be updated to render agents in collapsible sections. State management in `useManagementSocket.ts` will be adjusted to handle the grouped data structure.
- ~~[Warn on Browser Refresh](./feature/Warn-on-Refresh.md)~~: Warn user on browser refresh that sessions will be reset.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a straightforward, frontend-only feature.
  - **Backend:** No backend changes are required as session state is managed on the client.
  - **Frontend:** Requires adding a `beforeunload` event listener in a top-level component. The listener will check if any active sessions exist and, if so, trigger the browser's native confirmation prompt.
- ~~[Markdown Support](./feature/Markdown-Support.md)~~: Display markdown-formatted responses from the model in the ChatInterface.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a well-defined feature primarily focused on the frontend.
  - **Backend:** No backend changes are required. Agent responses are passed through as-is.
  - **Frontend:** Requires integrating a Markdown rendering library (like `react-markdown`) into the `ChatInterface.tsx` component. The component that displays agent messages will need to be updated to parse and render the markdown content instead of displaying it as plain text. Minimal state management changes are needed.
- ~~[Agent Code View](./feature/Agent-Code-View.md)~~: click a code icon in an agent card to see the code in a popup or viewer pane
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This is a well-defined feature with a clear implementation path.
  - **Backend:** Requires a new API endpoint (e.g., `/agents/{agent_id}/code`) that reads and returns the content of the agent's primary Python file. The backend already has logic for locating agent files.
  - **Frontend:** Requires adding a new icon/button to the `AgentListItem` component, a new function to fetch the code from the backend, and a new modal component to display the code. No major state management or architectural changes are needed.
- ~~[Improved Code Viewer](./feature/Improved-Code-Viewer.md)~~: In the Code Viewer, show a tabbed view for agents that have sub-agents.
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This feature enhances the existing Code Viewer.
  - **Backend:** Requires a new API endpoint to get the code for an agent and its sub-agents. This will involve identifying sub-agents (e.g., by looking for a `sub_agents` directory) and reading their code.
  - **Frontend:** The `CodeViewerModal.tsx` component will be updated to fetch the sub-agent code and display it in a tabbed interface.
- [README display for non-running agents](./feature/README-display.md): Display the README.md file for a selected agent in the ChatInterface pane when the agent is not running.
  - **Effort Assessment: FEATURE**
  - This is a quality-of-life feature that requires coordinated changes between the backend and frontend.
  - **Backend:** Requires a new API endpoint (e.g., `/agents/{agent_id}/readme`) that finds an agent's `README.md` file and returns its content.
  - **Frontend:** Requires several changes:
    - The `AgentSidebar.tsx` component must be modified to allow selecting agents that are not currently running.
    - State management in `App.tsx` must be updated to fetch and store the README content when a non-running agent is selected.
    - The `ChatInterface.tsx` component needs to be updated to display the fetched Markdown content when available, instead of the chat view.
- [Artifact service support](./feature/Artifact-service-support.md)
  - **Effort Assessment: FEATURE**
  - This feature is about integrating the ADK's built-in Artifact Service, not building one from scratch. The work is primarily plumbing and integration.
  - **Key tasks include:**
    - **ADK Integration:** The `agent_host.py` script must be updated to instantiate an `ArtifactService` (e.g., `InMemoryArtifactService`) and pass it to the ADK `Runner`.
    - **Agent-level API:** The agent's internal web server (in `agent_host.py`) needs a new endpoint to retrieve artifacts by name from the `ArtifactService`.
    - **Backend Proxy:** The main backend (`main.py`) needs a new endpoint that proxies artifact download requests from the frontend to the correct agent subprocess.
    - **Frontend:** The chat UI needs to be updated to recognize `artifact://` URIs in agent responses and render them as clickable download links pointing to the new backend proxy endpoint.
- [Backend logging levels](./feature/Backend-logging-levels.md)
  - **Effort Assessment: FEATURE**
  - This is a standard good-practice feature for any backend application.
  - **Implementation:** Involves replacing all `print()` statements in the backend Python code with the standard `logging` module. The logging level would be made configurable via an environment variable or a command-line argument to the Uvicorn server. This is a straightforward task with no architectural impact.
- [Event Viewer](./feature/Event-Viewer.md)
  - **Effort Assessment: FEATURE**
  - This feature is about correctly capturing and displaying the rich, structured event stream from the ADK. The project already has a minimal `EventStreamingPlugin` that forwards a subset of events, so the core plumbing exists.
  - **Key tasks include:**
    - **Backend Plugin Expansion:** The existing `backend/event_streaming_plugin.py` needs to be expanded to implement a comprehensive set of `BasePlugin` hooks (e.g., `on_start_turn`, `on_end_llm`, `on_error`) to capture the full agent lifecycle, not just tool calls.
    - **Frontend State Management:** The `useManagementSocket` hook must be modified to persistently store the full stream of incoming events for the selected agent, rather than clearing them after processing.
    - **New Frontend Component:** A new `EventViewer.tsx` component needs to be built. This component should be designed to render the hierarchical event data in a user-friendly way, such as a collapsible tree view, and would likely be added as a new tab in the `InfoPane`.
- [Connect to running agent(?)](./feature/Connect-to-running-agent.md)
  - **Effort Assessment: FEATURE**
  - This feature would allow the gallery to act as a client for agents that are running externally (i.e., not started by the gallery).
  - **Implementation:**
    - **Backend:** Requires a new API endpoint to register an external agent by its URL. The `/run_turn` logic would need to be updated to proxy requests to this URL for external agents, instead of using the local `AgentRunner`.
    - **Frontend:** Requires a new UI form for users to submit the name and URL of an external agent. The agent list UI would need to be adapted to display these "unmanaged" agents, disabling features that don't apply (like start/stop, logs, and event viewing).
- ~~[Agent-specific Configuration](./feature/Agent-Specific-Config.md)~~
  - **Status: Implemented & Merged**
  - **Effort Assessment: FEATURE**
  - This feature addresses the need for a scalable and maintainable way to provide unique configurations for different agents, replacing the current hardcoded shim for the RAG agent. The configuration is a host-level concern and should not be stored within the agent directories themselves. A centralized `agents.config.yaml` (gitignored) with an accompanying `agents.config.yaml.example` template now manages all agent-specific environment variables.

## TASKS
- Subagent support/testing (tools work, need to try subagent transfers)
- Test all ADK Sample Agents
- Agent Gallery Cloud Run deployment
    - Feature: instance-per agent option


## AGENTS
- ADK Samples
- To be added
    - A2A Samples
    - Implementation of https://cloud.google.com/architecture/multiagent-ai-system 
    - Agentic Design Patterns: https://docs.google.com/document/d/1rsaK53T3Lg5KoGwvf8ukOUvbELRtH-V0LnOIFDxBryE/edit?tab=t.0#heading=h.pxcur8v2qagu


## BACKLOG
- ~~Add "clear" button to agent filter. Circled X in right side of filter field~~ (Done)
- ~~When starting an agent discovered by the filter, clear the filter on start~~ (Done)
- subprocess check when processes crash
- Warn on unexpanded variables in `agents.config.yaml`. If a value contains a `$` after expansion, it likely means a host environment variable is missing. (may fix)
- Model Context Protocol example

## ASSISTED DEV IDEAS
- CLI Extension: /handoff
  - Summarizes the current state of progress into a prompt that can be used to restart after a /clear command.
- CLI Extension: /startup
  - Reads Gemini.md for directives and reports them, ensuring that they are active in the current session.
